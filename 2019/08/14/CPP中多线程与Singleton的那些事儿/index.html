<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="c++,">










<meta name="description" content="前言前段时间在网上看到了个的面试题，大概意思是如何在不使用锁和C++11的情况下，用C++实现线程安全的Singleton。 看到这个题目后，第一个想法就是用Scott Meyer在《Effective C++》中提到的，在static成员函数中构造local static变量的方法来实现，但是经过一番查找、思考，才明白这种实现在某些情况下是有问题的。本文主要将从最基本的单线程中的Singleto">
<meta name="keywords" content="c++">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP中多线程与Singleton的那些事儿">
<meta property="og:url" content="http://yoursite.com/2019/08/14/CPP中多线程与Singleton的那些事儿/index.html">
<meta property="og:site_name" content="Finalx&#39;s Space">
<meta property="og:description" content="前言前段时间在网上看到了个的面试题，大概意思是如何在不使用锁和C++11的情况下，用C++实现线程安全的Singleton。 看到这个题目后，第一个想法就是用Scott Meyer在《Effective C++》中提到的，在static成员函数中构造local static变量的方法来实现，但是经过一番查找、思考，才明白这种实现在某些情况下是有问题的。本文主要将从最基本的单线程中的Singleto">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-14T08:57:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CPP中多线程与Singleton的那些事儿">
<meta name="twitter:description" content="前言前段时间在网上看到了个的面试题，大概意思是如何在不使用锁和C++11的情况下，用C++实现线程安全的Singleton。 看到这个题目后，第一个想法就是用Scott Meyer在《Effective C++》中提到的，在static成员函数中构造local static变量的方法来实现，但是经过一番查找、思考，才明白这种实现在某些情况下是有问题的。本文主要将从最基本的单线程中的Singleto">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/14/CPP中多线程与Singleton的那些事儿/">





  <title>CPP中多线程与Singleton的那些事儿 | Finalx's Space</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Finalx's Space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/CPP中多线程与Singleton的那些事儿/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="finalx">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Finalx's Space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CPP中多线程与Singleton的那些事儿</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T16:57:41+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programing/" itemprop="url" rel="index">
                    <span itemprop="name">Programing</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programing/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/14/CPP中多线程与Singleton的那些事儿/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/08/14/CPP中多线程与Singleton的那些事儿/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间在网上看到了个的面试题，大概意思是如何在不使用锁和C++11的情况下，用C++实现线程安全的Singleton。</p>
<p>看到这个题目后，第一个想法就是用Scott Meyer在《Effective C++》中提到的，在static成员函数中构造local static变量的方法来实现，但是经过一番查找、思考，才明白这种实现在某些情况下是有问题的。本文主要将从最基本的单线程中的Singleton开始，慢慢讲述多线程与Singleton的那些事。</p>
<a id="more"></a>
<p>refer: <a href="https://www.cnblogs.com/liyuan989/p/4264889.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyuan989/p/4264889.html</a></p>
<hr>
<h1 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h1><p>在单线程下，下面这个是常见的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!value_)</span><br><span class="line">        &#123;</span><br><span class="line">            value_ = <span class="keyword">new</span> T();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>在单线程中，这样的写法是可以正确使用的，但是在多线程中就不行了。</strong></p>
<hr>
<h1 id="多线程加锁"><a href="#多线程加锁" class="headerlink" title="多线程加锁"></a>多线程加锁</h1><p>在多线程的环境中，上面单线程的写法就会产生race condition从而产生多次初始化的情况。要想在多线程下工作，最容易想到的就是用锁来保护shared variable了。下面是伪代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">MutexGuard <span class="title">guard</span><span class="params">(mutex_)</span>  <span class="comment">// RAII</span></span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(!value_)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                value_ = <span class="keyword">new</span> T();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> T*     value_;</span><br><span class="line">    <span class="keyword">static</span> Mutex  mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Mutex Singleton&lt;T&gt;::mutex_;</span><br></pre></td></tr></table></figure></p>
<p>这样在多线程下就能正常工作了。这时候，可能有人会站出来说这种做法每次调用getInstance的时候都会进入临界区，在频繁调用getInstance的时候会比较影响性能。这个时候，为了解决这个问题，DCL写法就被聪明的先驱者发明了。</p>
<hr>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p>DCL即double-checked locking。在普通加锁的写法中，每次调用getInstance都会进入临界区，这样在heavy contention的情况下该函数就会成为系统性能的瓶颈，这个时候就有先驱者们想到了DCL写法，也就是进行两次check，当第一次check为假时，才加锁进行第二次check：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!value_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">MutexGuard <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!value_)</span><br><span class="line">            &#123;</span><br><span class="line">                value_ = <span class="keyword">new</span> T();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> T*     value_;</span><br><span class="line">    <span class="keyword">static</span> Mutex  mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Mutex Singleton&lt;T&gt;::mutex_;</span><br></pre></td></tr></table></figure></p>
<p>是不是觉得这样就完美啦？其实在一段时间内，大家都以为这是正确的、有效的做法。实际上却不是这样的。幸运的是，后来有大牛们发现了DCL中的问题，避免了这样错误的写法在更多的程序代码中出现。</p>
<p>那么到底错在哪呢？我们先看看第12行value_ = new T这一句发生了什么：</p>
<ol>
<li>分配了一个T类型对象所需要的内存。</li>
<li>在分配的内存处构造T类型的对象。</li>
<li>把分配的内存的地址赋给指针value_</li>
</ol>
<p>主观上，我们会觉得计算机在会按照1、2、3的步骤来执行代码，但是问题就出在这。<strong>实际上只能确定步骤1最先执行，而步骤2、3的执行顺序却是不一定的</strong>。假如某一个线程A在调用getInstance的时候第12行的语句按照1、3、2的步骤执行，那么当刚刚执行完步骤3的时候发生线程切换，计算机开始执行另外一个线程B。因为第一次check没有上锁保护，那么在线程B中调用getInstance的时候，不会在第一次check上等待，而是执行这一句，那么此时value<em>已经被赋值了，就会直接返回*value</em>然后执行后面使用T类型对象的语句，但是在A线程中步骤3还没有执行！也就是说在B线程中通过getInstance返回的对象还没有被构造就被拿去使用了！这样就会发生一些难以debug的灾难问题。</p>
<p><strong>volatile关键字也不会影响执行顺序的不确定性。</strong></p>
<p>在多核心机器的环境下，2个核心同时执行上面的A、B两个线程时，由于第一次check没有锁保护，依然会出现使用实际没有被构造的对象的情况。</p>
<p>关于DCL问题的详细讨论分析，可以参考Scott Meyer的paper：<a href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf" target="_blank" rel="noopener">《C++ and the Perils of Double-Checked Locking》</a></p>
<p>不过在新的C++11中，这个问题得到了解决。因为新的C++11规定了新的内存模型，保证了执行上述3个步骤的时候不会发生线程切换，相当这个初始化过程是“原子性”的的操作，DCL又可以正确使用了，不过在C++11下却有更简洁的多线程Singleton写法了，这个留在后面再介绍。</p>
<p>关于新的C++11的内存模型，可以参考：<a href="http://www.chenlq.net/books/cpp11-faq/cpp11-faq-chinese-version-series-memory-model.html" target="_blank" rel="noopener">C++11中文版FAQ：内存模型</a>、<a href="http://www.stroustrup.com/C++11FAQ.html#memory-model" target="_blank" rel="noopener">C++11FAQ：Memory Model</a>、<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2556.html" target="_blank" rel="noopener">C++ Data-Dependency Ordering: Atomics and Memory Model</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/storage_duration</a>  :</p>
<blockquote>
<p>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with std::call_once).</p>
<p>Note: usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.</p>
<p>(since C++11)</p>
</blockquote>
<p>可能有人要问了，那么有什么办法可以在C++11之前的版本下，使得DCL正确工作呢？要使其正确执行的话，就得在步骤2、3直接加上一道memory barrier。强迫CPU执行的时候按照1、2、3的步骤来运行。(经网友@shines77提醒，因没有锁的缘故这里需要用RCU技法，即read-copy-update)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!value_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexGuard <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!value_)</span><br><span class="line">        &#123;</span><br><span class="line">            T* p = <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(T)));</span><br><span class="line">            <span class="keyword">new</span> (p) T();</span><br><span class="line">            <span class="comment">// insert some memory barier</span></span><br><span class="line">            value_ = p;  <span class="comment">// RCU method</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *value_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许有人会说，你这已经把先前的value_ = new T()这一句拆成了下面这样的两条语句, 为什么还要在后面插入some memory barrier？</p>
<p>原因是<strong>现代处理器都是以<a href="http://en.wikipedia.org/wiki/Out-of-order_execution" target="_blank" rel="noopener">Out-of-order execution</a>（乱序执行）的方式来执行指令的。现代CPU基本都是多核心的，一个核包含多个执行单元。例如，一个现代的Intel CPU 包含6个执行单元，可以做一组数学，条件逻辑和内存操作的组合。每个执行单元可以做这些任务的组合。这些执行单元并行地操作，允许指令并行地执行。如果从其它 CPU 来观察，这引入了程序顺序的另一层不确定性。</strong></p>
<p>如果站在单个CPU核心的角度上讲，它（一个CPU核心）看到的程序代码都是单线程的，所以它在内部以自己的“优化方式”乱序、并行的执行代码，然后保证最终的结果和按代码逻辑顺序执行的结果一致。但是如果我们编写的代码是多线程的，当不同线程访问、操作共享内存区域的时候，就会出现CPU实际执行的结果和代码逻辑所期望的结果不一致的情况。这是因为以单个CPU核心的视角来看代码是“单线程”的。</p>
<p>所以为了解决这个问题，就需要memory barrier了，利用它来强迫CPU按代码的逻辑顺序执行。例如上面改动版本的getInstance代码中，因为第10行有memory barrier，所以CPU执行第9、10、11按“顺序”执行的。即使在CPU核心内是并行执行指令（比如一个单元执行第9行、一个单元执行第11行）的，但是他们在退役单元（retirement unit）更新执行结果到通用寄存器或者内存中时也是按照9、10、11顺序更新的。例如一个单元A先执行完了第11行，CPU让单元A等待直到执行第9行的单元B执行完成并在退役单元更新完结果以后再在退役单元更新A的结果。</p>
<p>memory barreir是一种特殊的处理器指令，他指挥处理器做下面三件事：（参考文章<a href="http://www.domaigne.com/blog/computing/mutex-and-memory-visibility/" target="_blank" rel="noopener">Mutex And Memory Visibility</a>）</p>
<ul>
<li>刷新store buffer。</li>
<li>等待直到memory barreir之前的操作已经完成。</li>
<li>不将memory barreir之后的操作移到memory barreir之前执行。</li>
</ul>
<p>通过使用memory barreir，可以确保之前的乱序执行已经全部完成，并且未完成的写操作已全部刷新到主存。因此，数据一致性又重新回到其他线程的身边，从而保证正确内存的可见性。实际上，原子操作以及通过原子操作实现的模型（例如一些锁之类的），都是通过在底层加入memory barrier来实现的。</p>
<p>至于如何加入memory barrier，在unix上可以通过内核提供的barrier()宏来实现。或者直接嵌入ASM汇编指令mfence也可以，barrier宏也是通过该指令实现的。</p>
<p>关于memory barreir可以参考文章<a href="http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html" target="_blank" rel="noopener">Memory Barriers/Fences</a>。</p>
<hr>
<h1 id="Meyers-Singleton"><a href="#Meyers-Singleton" class="headerlink" title="Meyers Singleton"></a>Meyers Singleton</h1><p>Scott Meyer在《Effective C++》中提出了一种简洁的singleton写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> T value;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先说结论：</p>
<ul>
<li>单线程下，正确。</li>
<li>C++11及以后的版本（如C++14）的多线程下，正确。</li>
<li>C++11之前的多线程下，不一定正确。</li>
</ul>
<p>原因在于在C++11之前的标准中并没有规定local static变量的内存模型，所以很多编译器在实现local static变量的时候仅仅是进行了一次check（参考《深入探索C++对象模型》），于是getInstance函数被编译器改写成这样了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">char</span> value[<span class="keyword">sizeof</span>(T)];</span><br><span class="line"> </span><br><span class="line"><span class="function">T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!initialized)</span><br><span class="line">    &#123;</span><br><span class="line">       initialized = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">new</span> (value) T();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是乎它就是不是线程安全的了。</p>
<p>但是在C++11却是线程安全的，这是因为新的C++标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它。</p>
<p>在<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf" target="_blank" rel="noopener">C++11 standard</a>中的§6.7 [stmt.dcl] p4：</p>
<blockquote>
<p>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>
</blockquote>
<p>在stackoverflow中的<a href="http://stackoverflow.com/questions/1661529/is-meyers-implementation-of-singleton-pattern-thread-safe" target="_blank" rel="noopener">Is Meyers implementation of Singleton pattern thread safe?</a>这个问题中也有讨论到。</p>
<p>不过有些编译器在C++11之前的版本就支持这种模型，例如g++，从g++4.0开始，meyers singleton就是线程安全的，不需要C++11。其他的编译器就需要具体的去查相关的官方手册了。</p>
<hr>
<h1 id="Atomic-Singleton"><a href="#Atomic-Singleton" class="headerlink" title="Atomic Singleton"></a>Atomic Singleton</h1><p>在C++11之前的版本下，除了通过锁实现线程安全的Singleton外，还可以利用各个编译器内置的atomic operation来实现。（假设类Atomic是封装的编译器提供的atomic operation）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ready_.get())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> *value_;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (initializing_.getAndSet(<span class="literal">true</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// another thread is initializing, waiting in circulation</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    value_ = <span class="keyword">new</span> T();</span><br><span class="line">                    ready_.<span class="built_in">set</span>(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> *value_;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Atomic&lt;<span class="keyword">bool</span>&gt;  ready_;</span><br><span class="line">    <span class="keyword">static</span> Atomic&lt;<span class="keyword">bool</span>&gt;  initializing_;</span><br><span class="line">    <span class="keyword">static</span> T*            value_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Atomic&lt;<span class="keyword">int</span>&gt; Singleton&lt;T&gt;::ready_(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Atomic&lt;<span class="keyword">int</span>&gt; Singleton&lt;T&gt;::initializing_(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>肯定还有其他的写法，但是思路都差不多，需要区分三种状态：</p>
<ul>
<li>对象已经构造完成</li>
<li>对象还没有构造完成，但是某一线程正在构造中</li>
<li>对象还没有构造完成，也没有任何线程正在构造中</li>
</ul>
<hr>
<h1 id="pthread-once"><a href="#pthread-once" class="headerlink" title="pthread_once"></a>pthread_once</h1><p>如果是在unix平台的话，除了使用atomic operation外，在不适用C++11的情况下，还可以通过pthread_once来实现Singleton。</p>
<p>pthread_once的原型为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine)(void))</span><br></pre></td></tr></table></figure>
<p>APUE中对于pthread_once是这样说的：</p>
<blockquote>
<p>如果每个线程都调用pthread_once，系统就能保证初始化例程init_routine只被调用一次，即在系统首次调用pthread_once时。</p>
</blockquote>
<p>所以，我们就可以这样来实现Singleton了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> :</span> Nocopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        threads::pthread_once(&amp;once_control_, init);</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value_ = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span>  once_control_;</span><br><span class="line">    <span class="keyword">static</span> T*              value_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">pthread_once_t</span> Singleton&lt;T&gt;::once_control_ = PTHREAD_ONCE_INIT;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要正确的释放资源的话，可以在init函数里面使用glibc提供的atexit函数来注册相关的资源释放函数，从而达到了只在进程退出时才释放资源的这一目的。</p>
<hr>
<h1 id="static-object"><a href="#static-object" class="headerlink" title="static object"></a>static object</h1><p>现在再回头看看本文开头说的面试题的要求，不用锁和C++11，那么可以通过atomic operation来实现，但是有人会说atomic不是夸平台的，各个编译器的实现不一样。那么其实通过static object来实现也是可行的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Helper()</span><br><span class="line">        &#123;</span><br><span class="line">            Singleton&lt;T&gt;::value_ = <span class="keyword">new</span> T();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ~Helper()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value_;</span><br><span class="line">            value_ = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> T*      value_;</span><br><span class="line">    <span class="keyword">static</span> Helper  helper_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Singleton&lt;T&gt;::Helper Singleton&lt;T&gt;::helper_;</span><br></pre></td></tr></table></figure>
<p>在进入main之前就把Singleton对象构造出来就可以避免在进入main函数后的多线程环境中构造的各种情况了。这种写法有一个前提就是不能在main函数执行之前调用getInstance，因为C++标准只保证静态变量在main函数之前之前被构造完成。</p>
<p>可能有人会说如果helper的初始化先于value<em>初始化的话，那么helper</em>初始化的时候就会使用尚没有被初始化的value<em>，这个时候使用其返回的对象就会出现问题，或者在后面value</em>“真正”初始化的时候会覆盖掉helper<em>初始化时赋给value</em>的值。</p>
<p>实际上这种情况不会发生，value<em>的初始化一定先于helper</em>，因为C++标准保证了这一行为：</p>
<blockquote>
<p>The storage for objects with static storage duration (basic.stc.static) shall be zero-initialized (dcl.init) before any other initialization takes place. Zero-initialization and initialization with a constant expression are collectively called static initialization; all other initialization is dynamic initialization. Objects of POD types (basic.types) with static storage duration initialized with constant expressions (expr.const) shall be initialized before any dynamic initialization takes place. Objects with static storage duration defined in namespace scope in the same translation unit and dynamically initialized shall be initialized in the order in which their definition appears in the translation unit.</p>
</blockquote>
<p>stackoverflow中的一个问题也讨论了相关的行为，<a href="http://stackoverflow.com/questions/1421671/when-are-static-c-class-members-initialized" target="_blank" rel="noopener">When are static C++ class members initialized</a>?</p>
<hr>
<h1 id="local-static"><a href="#local-static" class="headerlink" title="local static"></a>local static</h1><p>上面一种写法只能在进入main函数后才能调用getInstance，那么有人说，我要在main函数之前调用怎么办？</p>
<p>嗯，办法还是有的。这个时候我们就可以利用local static来实现，C++标准保证函数内的local static变量在函数调用之前被初始化构造完成，利用这一特性就可以达到目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Creater</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Creater()</span><br><span class="line">            : value_(<span class="keyword">new</span> T())</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ~Creater()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> value_;</span><br><span class="line">            value_ = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function">T&amp; <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> *value_;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        T* value_;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Creater creater;</span><br><span class="line">        <span class="keyword">return</span> creater.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dummy</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Dummy()</span><br><span class="line">        &#123;</span><br><span class="line">            Singleton&lt;T&gt;::getInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Dummy dummy_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Singleton&lt;T&gt;::Dummy Singleton&lt;T&gt;::dummy_;</span><br></pre></td></tr></table></figure>
<p>这样就可以了。dummy_的作用是即使在main函数之前没有调用getInstance，它依然会作为最后一道屏障保证在进入main函数之前构造完成Singleton对象。这样就避免了在进入main函数后的多线程环境中初始化的各种问题了。</p>
<p>但是此种方法只能在main函数执行之前的环境是单线程的环境下才能正确工作。</p>
<p>实际上，上文所讲述了各种写法中，有一些不能在main函数之前调用。有一些可以在main函数之前调用，但是必须在进入main之前的环境是单线程的情况下才能正常工作。具体哪种写法是属于这两种情况就不一一分析了。总之，个人建议最好不要在进入main函数之前获取Singleton对象。因为上文中的各种方法都用到了staitc member，而C++标准只保证static member在进入main函数之前初始化，但是不同编译单元之间的static member的初始化顺序却是未定义的， 所以如果在main之前就调用getInstance的话，就有可能出现实现Singleton的static member还没有初始化就被使用的情况。</p>
<p>如果万一要在main之前获取Singleton对象，并且进入main之前的环境是多线程环境，这种情形下，还能保证正常工作的写法只有C++ 11下的Meyers Singleton，或者如g++ 4.0及其后续版本这样的编译器提前支持内存模型情况下的C++ 03也是可以的。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag"># c++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/09/Aomono-yokocho/" rel="next" title="Aomono-yokocho">
                <i class="fa fa-chevron-left"></i> Aomono-yokocho
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/28/Secure-Tomcat-Hosting-Restrict-Access-to-Your-Web-Application/" rel="prev" title="Secure Tomcat Hosting: Restrict Access to Your Web Application">
                Secure Tomcat Hosting: Restrict Access to Your Web Application <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="finalx">
            
              <p class="site-author-name" itemprop="name">finalx</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单线程"><span class="nav-number">2.</span> <span class="nav-text">单线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程加锁"><span class="nav-number">3.</span> <span class="nav-text">多线程加锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DCL"><span class="nav-number">4.</span> <span class="nav-text">DCL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Meyers-Singleton"><span class="nav-number">5.</span> <span class="nav-text">Meyers Singleton</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Atomic-Singleton"><span class="nav-number">6.</span> <span class="nav-text">Atomic Singleton</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pthread-once"><span class="nav-number">7.</span> <span class="nav-text">pthread_once</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static-object"><span class="nav-number">8.</span> <span class="nav-text">static object</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#local-static"><span class="nav-number">9.</span> <span class="nav-text">local static</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">finalx</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://finalx.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2019/08/14/CPP中多线程与Singleton的那些事儿/';
          this.page.identifier = '2019/08/14/CPP中多线程与Singleton的那些事儿/';
          this.page.title = 'CPP中多线程与Singleton的那些事儿';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://finalx.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
