<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/favicon.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,Graphics,Fence," />










<meta name="description" content="转载自 http://blog.csdn.net/jinzhuojun/article/details/39698317转载自http://blog.csdn.net/ear5cm/article/details/45093807Edited: 增加了fence的翻译 android-fences-introduction Fence在Graphics中的应用Fence是一种同步机制，在Andro">
<meta name="keywords" content="Android,Graphics,Fence">
<meta property="og:type" content="article">
<meta property="og:title" content="Android中的GraphicBuffer同步机制-Fence">
<meta property="og:url" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/index.html">
<meta property="og:site_name" content="Finalx&#39;s Space">
<meta property="og:description" content="转载自 http://blog.csdn.net/jinzhuojun/article/details/39698317转载自http://blog.csdn.net/ear5cm/article/details/45093807Edited: 增加了fence的翻译 android-fences-introduction Fence在Graphics中的应用Fence是一种同步机制，在Andro">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/bq_states.png">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/bq_sync_relation.png">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/sf_comp.png">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/cs_buffer.png">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/aquireFence.png">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/releaseFence.png">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/producer_allocator_cunsumer.jpg">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/sync_components.jpg">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/tl_pt_fence_relation.png">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/timeline_create.jpg">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/fence_create.jpg">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/timeline_inc.jpg">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/sync_wait.jpg">
<meta property="og:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/close_fence_timeline.jpg">
<meta property="og:updated_time" content="2017-09-30T08:38:36.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android中的GraphicBuffer同步机制-Fence">
<meta name="twitter:description" content="转载自 http://blog.csdn.net/jinzhuojun/article/details/39698317转载自http://blog.csdn.net/ear5cm/article/details/45093807Edited: 增加了fence的翻译 android-fences-introduction Fence在Graphics中的应用Fence是一种同步机制，在Andro">
<meta name="twitter:image" content="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/bq_states.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/"/>





  <title>Android中的GraphicBuffer同步机制-Fence | Finalx's Space</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Finalx's Space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="finalx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Finalx's Space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android中的GraphicBuffer同步机制-Fence</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T11:25:09+08:00">
                2017-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Graphics/" itemprop="url" rel="index">
                    <span itemprop="name">Graphics</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/09/30/Android中的GraphicBuffer同步机制-Fence/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/09/30/Android中的GraphicBuffer同步机制-Fence/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><em>转载自 <a href="http://blog.csdn.net/jinzhuojun/article/details/39698317" target="_blank" rel="noopener">http://blog.csdn.net/jinzhuojun/article/details/39698317</a></em><br><em>转载自<a href="http://blog.csdn.net/ear5cm/article/details/45093807" target="_blank" rel="noopener">http://blog.csdn.net/ear5cm/article/details/45093807</a></em><br><em>Edited: 增加了fence的翻译 <a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html" target="_blank" rel="noopener">android-fences-introduction</a></em></p>
<h1 id="Fence在Graphics中的应用"><a href="#Fence在Graphics中的应用" class="headerlink" title="Fence在Graphics中的应用"></a>Fence在Graphics中的应用</h1><p>Fence是一种同步机制，在Android里主要用于图形系统中GraphicBuffer的同步。 那它和已有同步机制相比有什么特点呢？</p>
<p>它主要被用来处理跨硬件的情况，尤其是CPU，GPU和HWC之间的同步，另外它还可以用于多个时间点之间的同步。<br>GPU编程和纯CPU编程一个很大的不同是它是异步的，也就是说当我们调用GL command返回时这条命令并不一定完成了，只是把这个命令放在本地的command buffer里。具体什么时候这条GL command被真正执行完毕CPU是不知道的，除非CPU使用glFinish()等待这些命令执行完，另外一种方法就是基于同步对象的Fence机制。下面举个生产者把GraphicBuffer交给消费者的例子。 </p>
<p>如生产者是App中的renderer，消费者是SurfaceFlinger。GraphicBuffer的队列放在缓冲队列BufferQueue中。BufferQueue对App端的接口为IGraphicBufferProducer，实现类为Surface，对SurfaceFlinger端的接口为IGraphicBufferConsumer，实现类为SurfaceFlingerConsumer。BufferQueue中对每个GraphiBuffer都有BufferState标记着它的状态：<br><a id="more"></a><br><img src="/2017/09/30/Android中的GraphicBuffer同步机制-Fence/bq_states.png" title="BQ状态迁移"></p>
<p>这个状态一定程度上说明了该GraphicBuffer的归属，但只指示了CPU里的状态，而GraphicBuffer的真正使用者是GPU。也就是说，当生产者把一个GraphicBuffer放入BufferQueue时，只是在CPU层面完成了归属的转移。但GPU说不定还在用，如果还在用的话消费者是不能拿去合成的。这时候GraphicBuffer和生产消费者的关系就比较暧昧了，消费者对GraphicBuffer具有拥有权，但无使用权，它需要等一个信号，告诉它GPU用完了，消费者才真正拥有使用权。一个简化的模型如下：<br><img src="bq_sync_relation.png" alt=""></p>
<p>这个通知GraphicBuffer被上一个使用者用完的信号就是由Fence完成的。Fence的存在非常单纯，从诞生开始就是为了在合适的时间发出一个信号。另一个角度来说，为什么不在生产者把GraphicBuffer交给消费者时就调用glFinish()等GPU完成呢？这样拥有权和使用权就一并传递了，无需Fence。就功能上这样做是可以的，但性能会有影响，因为glFinish()是阻塞的，这时CPU为了等GPU自己也不能工作了。如果用Fence的话就可以等这个GraphicBuffer真正要被消费者用到时再阻塞，而那之前CPU和GPU是可以并行工作的。这样相当于实现了临界资源的lazy passing。</p>
<p>说完Fence的基本作用，再说下它的实现。Fence，顾名思义就是把先到的拦住，等后来的，两者步调一致了再往前走。抽象地说，Fence包含了同一或不同时间轴上的多个时间点，只有当这些点同时到达时Fence才会被触发.</p>
<p>Fence可以由硬件实现(Graphic driver)，也可以由软件实现(Android kernel中的sw_sync)。EGL中提供了同步对象的扩展KHR_fence_sync [<a href="http://www.khronos.org/registry/vg/extensions/KHR/EGL_KHR_fence_sync.txt" target="_blank" rel="noopener">http://www.khronos.org/registry/vg/extensions/KHR/EGL_KHR_fence_sync.txt</a>] 。其中提供了eglCreateSyncKHR ()，eglDestroySyncKHR()产生和销毁同步对象。这个同步对象是往GL command队列中插入的一个特殊操作，当执行到它时，会发出信号指示队列前面的命令已全部执行完毕。函数eglClientWaitSyncKHR()可让调用者阻塞等待信号发生。</p>
<p>在此基础之上，Android对其进行了扩展-ANDROID_native_fence_sync  [<a href="http://www.khronos.org/registry/egl/extensions/ANDROID/EGL_ANDROID_native_fence_sync.txt" target="_blank" rel="noopener">http://www.khronos.org/registry/egl/extensions/ANDROID/EGL_ANDROID_native_fence_sync.txt</a>] ，新加了接口eglDupNativeFenceFDANDROID()。它可以把一个同步对象转化为一个文件描述符（反过来，eglCreateSyncKHR()可以把文件描述符转成同步对象)。这个扩展相当于让CPU中有了GPU中同步对象的句柄，文件描述符可以在进程间传递(通过binder或domain socket等IPC机制)，这就为多进程间的同步提供了基础。我们知道Unix系统一切皆文件，因此，有个这个扩展以后Fence的通用性大大增强了。</p>
<p>Android还进一步丰富了Fence的software stack。主要分布在三部分：</p>
<ul>
<li>C++ Fence类位于/frameworks/native/libs/ui/Fence.cpp</li>
<li>C的libsync库位于/system/core/libsync/sync.c</li>
<li>Kernel driver部分位于/drivers/base/sync.c</li>
</ul>
<p>总得来说，kernel driver部分是同步的主要实现，libsync是对driver接口的封装，Fence是对libsync的进一步的C++封装。Fence会被作为GraphicBuffer的附属随着GraphicBuffer在生产者和消费间传输。另外Fence的软件实现位于/drivers/base/sw_sync.c。SyncFeatures用以查询系统支持的同步机制：/frameworks/native/libs/gui/SyncFeatures.cpp。</p>
<p>下面分析下Fence在Android中的具体用法。它主要的作用是GraphicBuffer在App, GPU和HWC三者间传递时作同步。</p>
<p>首先温故一下GraphicBuffer从App到Display的旅程:</p>
<ul>
<li>GraphicBuffer先由App端作为生产者进行绘制，然后放入到BufferQueue，等待消费者取出作下一步的渲染合成。</li>
<li>SurfaceFlinger作为消费者，会把每个层对应的GraphicBuffer取来生成EGLImageKHR对象。合成时对于GraphicBuffer的处理分两种情况。<ul>
<li>对于Overlay的层，SurfaceFlinger会直接将其buffer handle放入HWC的Layer list。</li>
<li>对于需要GPU绘制的层（超出HWC处理层数或者有复杂变换的），SurfaceFlinger会将前面生成的EGLImageKHR通过glEGLImageTargetTexture2DOES()作为纹理进行合成。合成完后SurfaceFlinger又作为生产者，把GPU合成好的framebuffer的handle置到HWC中的FramebufferTarget中(HWC中hwc_display_contents_1_t中的hwc_layer_1_t列表最后一个slot用于放GPU的渲染结果所在buffer)。HWC最后叠加Overlay层再往Display上扔，这时HWC是消费者。</li>
</ul>
</li>
</ul>
<p>整个大致流程如图：<br><img src="sf_comp.png" alt=""></p>
<p>可以看到，对于非Overlay的层来说GraphicBuffer先后经过两个生产消费者模型。我们知道GraphicBuffer核心包含的是buffer_handle_t结构，它指向的native_handle_t包含了gralloc中申请出来的图形缓冲区的文件描述符和其它基本属性，这个文件描述符会被同时映射到客户端和服务端，作为共享内存。<br><img src="cs_buffer.png" alt=""></p>
<p>由于服务和客户端进程都可以访问同一物理内存，因此不加同步的话会引起错误。为了协调客户端和服务端，在传输GraphicBuffer时，还带有Fence，标志了它是否被上一个使用者使用完毕。Fence按作用大体分两种：<strong>acquireFence</strong>和<strong>releaseFence</strong>。前者用于生产者通知消费者生产已完成，后者用于消费者通知生产者消费已完成。<br>下面分别看一下这两种Fence的产生和使用过程。</p>
<p>首先是acquireFence的使用流程：<br><img src="aquireFence.png" alt=""></p>
<p>当App端通过queueBuffer()向BufferQueue插入GraphicBuffer时，会顺带一个Fence，这个Fence指示这个GraphicBuffer是否已被生产者用好。之后该GraphicBuffer被消费者通过acquireBuffer()拿走，同时也会取出这个acquireFence。之后消费者（也就是SurfaceFlinger）要把它拿来渲染时，需要等待Fence被触发。如果该层是通过GPU渲染的，那么使用它的地方是Layer::onDraw()，其中会通过bindTextureImage()绑定纹理：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">486</span>    <span class="keyword">status_t</span> err = mSurfaceFlingerConsumer-&gt;bindTextureImage();</span><br></pre></td></tr></table></figure></p>
<p>该函数最后会调用doGLFenceWaitLocked()等待acquireFence触发。因为再接下来就是要拿来画了，如果这儿不等待直接往下走，那渲染出来的就是错误的内容。</p>
<p>如果该层是HWC渲染的Overlay层，那么不需要经过GPU，那就需要把这些层对应的acquireFence传到HWC中。这样，HWC在合成前就能确认这个buffer是否已被生产者使用完，因此一个正常点的HWC需要等这些个acquireFence全被触发才能去绘制。这个设置的工作是在SurfaceFlinger::doComposeSurfaces()中完成的，该函数会调用每个层的layer::setAcquireFence()函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">428</span>    <span class="keyword">if</span> (layer.getCompositionType() == HWC_OVERLAY) &#123;</span><br><span class="line"><span class="number">429</span>        sp&lt;Fence&gt; fence = mSurfaceFlingerConsumer-&gt;getCurrentFence();</span><br><span class="line">...</span><br><span class="line"><span class="number">431</span>            fenceFd = fence-&gt;dup();</span><br><span class="line">...</span><br><span class="line"><span class="number">437</span>    layer.setAcquireFenceFd(fenceFd);</span><br></pre></td></tr></table></figure></p>
<p>可以看到其中忽略了非Overlay的层，因为HWC不需要直接和非Overlay层同步，它只要和这些非Overlay层合成的结果FramebufferTarget同步就可以了。GPU渲染完非Overlay的层后，通过queueBuffer()将GraphicBuffer放入FramebufferSurface对应的BufferQueue，然后FramebufferSurface::onFrameAvailable()被调用。它先会通过nextBuffer()-&gt;acquireBufferLocked()从BufferQueue中拿一个GraphicBuffer，附带拿到它的acquireFence。接着调用HWComposer::fbPost()-&gt;setFramebufferTarget()，其中会把刚才acquire的GraphicBuffer连带acquireFence设到HWC的Layer list中的FramebufferTarget slot中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">580</span>        acquireFenceFd = acquireFence-&gt;dup();</span><br><span class="line">...</span><br><span class="line"><span class="number">586</span>    disp.framebufferTarget-&gt;acquireFenceFd = acquireFenceFd;</span><br></pre></td></tr></table></figure></p>
<p>综上，HWC进行最后处理的前提是Overlay层的acquireFence及FramebufferTarget的acquireFence都被触发。</p>
<p>看完acquireFence，再看看releaseFence的使用流程：<br><img src="releaseFence.png" alt=""></p>
<p>前面提到合成的过程先是GPU工作，在doComposition()函数中合成非Overlay的层，结果放在framebuffer中。然后SurfaceFlinger会调用postFramebuffer()让HWC开始工作。postFramebuffer()中最主要是调用HWC的set()接口通知HWC进行合成显示，然后会将HWC中产生的releaseFence（如有）同步到SurfaceFlingerConsumer中。实现位于Layer的onLayerDisplayed()函数中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">151</span>        mSurfaceFlingerConsumer-&gt;setReleaseFence(layer-&gt;getAndResetReleaseFence());</span><br></pre></td></tr></table></figure></p>
<p>上面主要是针对Overlay的层，那对于GPU绘制的层呢？在收到INVALIDATE消息时，SurfaceFlinger会依次调用handleMessageInvalidate()-&gt;handlePageFlip()-&gt;Layer::latchBuffer()-&gt;SurfaceFlingerConsumer::updateTexImage() ，其中会调用该层对应Consumer的GLConsumer::updateAndReleaseLocked() 函数。该函数会释放老的GraphicBuffer，释放前会通过syncForReleaseLocked()函数插入releaseFence，代表如果触发时该GraphicBuffer消费者已经使用完毕。然后调用releaseBufferLocked()还给BufferQueue，当然还带着这个releaseFence。这样，当这个GraphicBuffer被生产者再次通过dequeueBuffer()拿出时，就可以通过这个releaseFence来判断消费者是否仍然在使用。</p>
<p>另一方面，HWC合成完毕后，SurfaceFlinger会依次调用DisplayDevice::onSwapBuffersCompleted() -&gt; FramebufferSurface::onFrameCommitted()。onFrameCommitted()核心代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">148</span>    sp&lt;Fence&gt; fence = mHwc.getAndResetReleaseFence(mDisplayType);</span><br><span class="line">...</span><br><span class="line"><span class="number">151</span>        <span class="keyword">status_t</span> err = addReleaseFence(mCurrentBufferSlot,</span><br><span class="line"><span class="number">152</span>                mCurrentBuffer, fence);</span><br></pre></td></tr></table></figure></p>
<p>此处拿到HWC生成的FramebufferTarget的releaseFence，设到FramebufferSurface中相应的GraphicBuffer Slot中。这样FramebufferSurface对应的GraphicBuffer也可以被释放回BufferQueue了。当将来EGL从中拿到这个buffer时，照例也要先等待这个releaseFence触发才能使用。</p>
<hr>
<h1 id="Android-Synchronization-Fences-–-An-Introduction"><a href="#Android-Synchronization-Fences-–-An-Introduction" class="headerlink" title="Android Synchronization Fences – An Introduction"></a>Android Synchronization Fences – An Introduction</h1><p><em>翻译自<a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html" target="_blank" rel="noopener">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></em></p>
<p>使用生产者和消费者之间交换 buffer 的系统, 都需要一种策略来控制 buffer lifecycle（分配/释放）及对buffer（读/写）的access。 buffer访问控制策略确定生产者或消费者是否可以互斥的方式访问buffer。</p>
<p>Android Fence是一种实现特定缓冲访问控制策略的机制，并且不处理buffer lifecycle（分配/释放, 这是由BufferQueue/Gralloc来控制的）, 允许Producer:Consumers 为1:N的关系。 Fence 工作在Buffer之外（即它不是Buffer结构的一部分）， 用于同步Producer和Comsumer之间的Buffer所有权(access)的交换。<br>特别重要的是，在Android要求使用Fence的情况下，消费者仅仅获得到Buffer的pointer是不够的 - 即使是由生产者显式提供的，还必须得到Fence授权才可以access这块buffer.</p>
<p><img src="producer_allocator_cunsumer.jpg" alt=""></p>
<h2 id="Timelines-Synchronization-Points-and-Fences"><a href="#Timelines-Synchronization-Points-and-Fences" class="headerlink" title="Timelines, Synchronization Points and Fences"></a>Timelines, Synchronization Points and Fences</h2><p>要充分了解Android Fence，还需要熟悉Timelines和Sync point。 内核文档（linux / kernel / Documentation / sync.txt）提供了有关我可以找到的这些概念的唯一信息来源，我把它放在这里：</p>
<blockquote>
<p>Motivation:</p>
<p>In complicated DMA pipelines such as graphics (multimedia, camera, gpu, display)<br>a consumer of a buffer needs to know when the producer has finished producing<br>it.  Likewise the producer needs to know when the consumer is finished with the<br>buffer so it can reuse it.  A particular buffer may be consumed by multiple<br>consumers which will retain the buffer for different amounts of time.  In<br>addition, a consumer may consume multiple buffers atomically.<br>The sync framework adds an API which allows synchronization between the<br>producers and consumers in a generic way while also allowing platforms which<br>have shared hardware synchronization primitives to exploit them.</p>
<p>Goals:</p>
<pre><code>* provide a generic API for expressing synchronization dependencies
* allow drivers to exploit hardware synchronization between hardware blocks
* provide a userspace API that allows a compositor to manage dependencies.
* provide rich telemetry data to allow debugging slowdowns and stalls of the graphics pipeline.
</code></pre><p>Objects:</p>
<pre><code>* sync_timeline
* sync_pt
* sync_fence
</code></pre><p>sync_timeline:</p>
<p>A sync_timeline is an abstract monotonically increasing counter. In general,<br>each driver/hardware block context will have one of these.  They can be backed<br>by the appropriate hardware or rely on the generic sw_sync implementation.<br>Timelines are only ever created through their specific implementations<br>(i.e. sw_sync.)</p>
<p>sync_pt:</p>
<p>A sync_pt is an abstract value which marks a point on a sync_timeline. Sync_pts<br>have a single timeline parent.  They have 3 states: active, signaled, and error.<br>They start in active state and transition, once, to either signaled (when the<br>timeline counter advances beyond the sync_pt’s value) or error state.</p>
<p>sync_fence:</p>
<p>Sync_fences are the primary primitives used by drivers to coordinate<br>synchronization of their buffers.  They are a collection of sync_pts which may<br>or may not have the same timeline parent.  A sync_pt can only exist in one fence<br>and the fence’s list of sync_pts is immutable once created.  Fences can be<br>waited on synchronously or asynchronously.  Two fences can also be merged to<br>create a third fence containing a copy of the two fences’ sync_pts.  Fences are<br>backed by file descriptors to allow userspace to coordinate the display pipeline<br>dependencies.</p>
<p>Use:</p>
<p>A driver implementing sync support should have a work submission function which:</p>
<pre><code>* takes a fence argument specifying when to begin work
* asynchronously queues that work to kick off when the fence is signaled
* returns a fence to indicate when its work will be done.
* signals the returned fence once the work is completed.
</code></pre><p>Consider an imaginary display driver that has the following API:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * assumes buf is ready to be displayed.</span></span><br><span class="line"><span class="comment"> * blocks until the buffer is on screen.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display_buffer</span><span class="params">(struct dma_buf *buf)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>The new API will become:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * will display buf when fence is signaled.</span></span><br><span class="line"><span class="comment"> * returns immediately with a fence that will signal when buf</span></span><br><span class="line"><span class="comment"> * is no longer displayed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct sync_fence* <span class="title">display_buffer</span><span class="params">(struct dma_buf *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 struct sync_fence *fence)</span></span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>上述对象之间的关系如下 2图 所示。<br><img src="sync_components.jpg" alt="图1"><br><img src="tl_pt_fence_relation.png" alt="图2"></p>
<h2 id="Android-Fence实现细节"><a href="#Android-Fence实现细节" class="headerlink" title="Android Fence实现细节"></a>Android Fence实现细节</h2><p>userspace 代码可以在C ++实现（使用Fence类）和C代码库实现之间进行选择。 C ++实现只是围绕C sync库代码的精简包装，而C库只是在实现sync API的内核设备上调用ioctl系统调用。</p>
<ul>
<li>Android内核包括“sync”模块，也称为Synchronization 框架，它实现了timeline, sync point, fence。 该模块可以由选择实现sync API的deriver利用。</li>
<li>内核还包括一个sw timeline driver/ (dev / sync)，该driver实现了一个基于软件的timeline， SW timeline 驱动使用内核的Synchronization框架。</li>
</ul>
<h3 id="了解Sync-API"><a href="#了解Sync-API" class="headerlink" title="了解Sync API"></a>了解Sync API</h3><p>在用户空间中使用Synchronization API的第一步是创建timeline handle（文件描述符）。 下面的示例调用流程显示了用户空间C库如何使用函数sw_sync_timeline_create为generic software timeline（sw_sync）的实例创建一个句柄。<br><img src="timeline_create.jpg" alt=""></p>
<p>创建timeline后，用户可以任意增加timeline计数器（ sw_sync_timeline_inc ）或创建fence handle（ sw_sync_fence_create ）。 每个fence最初在时间线上包含一个sync point。<br><img src="fence_create.jpg" alt=""></p>
<p>如果用户需要两个或更多的sync point附加到Fence，可以这样搞: 再创建一个Fence，然后将它们合并在一起（ sync_merge ）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个generic 的sw_sync时间轴</span></span><br><span class="line"><span class="keyword">int</span> sw_timelime = sw_sync_timeline_create（）;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在sw_sync时间轴上创建两个Fence with sync point 2和5</span></span><br><span class="line"><span class="keyword">int</span> sw_fence1 = sw_sync_fence_create（sw_timeline，“fence1”，<span class="number">2</span>）;</span><br><span class="line"><span class="keyword">int</span> sw_fence2 = sw_sync_fence_create（sw_timeline，“fence2”，<span class="number">5</span>）;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并sw_fence1和sw_fence2以创建包含的单个Fence</span></span><br><span class="line"><span class="comment">//两个同步点</span></span><br><span class="line"><span class="keyword">int</span> sw_fence3 = sync_merge（“fence3”，sw_fence1，sw_fence2）;</span><br></pre></td></tr></table></figure></p>
<p>内核sync API（用于内核模块）类似，但需要显式创建同步点：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个通用的sw_sync时间轴</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sync_timeline</span> * <span class="title">timeline</span> = <span class="title">sw_sync_timeline_create</span>（“<span class="title">some_name</span>”）;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个sync_pt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sync_pt</span> * <span class="title">pt</span> = <span class="title">sw_sync_pt_create</span>（<span class="title">sfb</span>-&gt; <span class="title">timeline</span>，<span class="title">sfb</span>-&gt; <span class="title">timeline_max</span>）;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个附加到sync_pt的Fence</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sync_fence</span> * <span class="title">fence</span> = <span class="title">sync_fence_create</span>（“<span class="title">some_other_name</span>”，<span class="title">pt</span>）;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件描述符附加到Fence</span></span><br><span class="line"><span class="keyword">int</span> fd = get_unused_fd（）</span><br><span class="line">sync_fence_install（fence，fd）;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Fence进行同步"><a href="#使用Fence进行同步" class="headerlink" title="使用Fence进行同步"></a>使用Fence进行同步</h2><p>回想一下，timeline抽象代表一个单调递增的计数器，sync point代表该计数器的特定未来值（时间线上的点）, timeline如何增加是timeline specificed。 例如，</p>
<ul>
<li>GPU可以使用内部时钟计数器中断来增加其 timeline 计数器。 </li>
<li>在调用sw_sync_timeline_inc时，使用Synchronization API 的app手动增加generic sw_sync时间轴。</li>
</ul>
<p>sync point 值的意义和两个sync point 如何比较的方法也是时间轴特定的。 sw_sync设备在线上绘制简单点。 当Sync框架收到时间轴计数器增加的通知时，它将测试计数器是否达到时间轴上现有同步点的时间轴值，并触发相关Fence上的唤醒事件 – <strong>Whenever the Synchronization framework is notified of timeline counter increase, it tests if the counter reached (or passed) the timeline value of existing synchronization points on the timeline and triggers wake-up events on the relevant fences.</strong></p>
<p><img src="timeline_inc.jpg" alt=""></p>
<p>Userspace 模块通过sync_wait API来获得Fence状态改变, Kernel 模块里也有类似的API，另外kernel模块还可以使用异步Fence状态更改通知的API（通过回调注册）。<br><img src="sync_wait.jpg" alt=""></p>
<p>当用户空间关闭一个有效的<strong>sync_timeline</strong>句柄时，Sync框架会检查是否需要在该<strong>Timeline</strong>上signal()持有相应Syncpoint的<strong>Fence</strong>, 而关闭<strong>Fence</strong>句柄不会触发signal(): 只会从相应的时间线上移除包含在该Fence上的同步点。<br><img src="close_fence_timeline.jpg" alt=""></p>
<hr>
<p>参考:</p>
<ul>
<li>Userspace C++ Fence Wrapper<br>  frameworks/native/libs/ui/Fence.cpp<br>  frameworks/native/include/ui/Fence.h</li>
<li>Userspace C Library<br>  system/core/libsync/sync.c </li>
<li>Kernel Software Timeline<br>  kernel/drivers/staging/android/sw_sync.h<br>  kernel/drivers/staging/android/sw_sync.c<br>  external/kernel-headers/original/linux/sw_sync.h </li>
<li>Kernel Fence Framework<br>  external/kernel-headers/original/linux/sync.h<br>  kernel/drivers/staging/android/sync.h<br>  kernel/drivers/staging/android/sync.c</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/Graphics/" rel="tag"># Graphics</a>
          
            <a href="/tags/Fence/" rel="tag"># Fence</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/29/Install-JDK1-8-Tomcat8-Opengrok-for-Ubuntu-14-04/" rel="next" title="Install JDK1.8/Tomcat8/Opengrok for Ubuntu 14.04">
                <i class="fa fa-chevron-left"></i> Install JDK1.8/Tomcat8/Opengrok for Ubuntu 14.04
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/16/NOTES/" rel="prev" title="NOTES">
                NOTES <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="finalx" />
            
              <p class="site-author-name" itemprop="name">finalx</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Fence在Graphics中的应用"><span class="nav-number">1.</span> <span class="nav-text">Fence在Graphics中的应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-Synchronization-Fences-–-An-Introduction"><span class="nav-number">2.</span> <span class="nav-text">Android Synchronization Fences – An Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Timelines-Synchronization-Points-and-Fences"><span class="nav-number">2.1.</span> <span class="nav-text">Timelines, Synchronization Points and Fences</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-Fence实现细节"><span class="nav-number">2.2.</span> <span class="nav-text">Android Fence实现细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解Sync-API"><span class="nav-number">2.2.1.</span> <span class="nav-text">了解Sync API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Fence进行同步"><span class="nav-number">2.3.</span> <span class="nav-text">使用Fence进行同步</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">finalx</span>

  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://finalx.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/09/30/Android中的GraphicBuffer同步机制-Fence/';
          this.page.identifier = '2017/09/30/Android中的GraphicBuffer同步机制-Fence/';
          this.page.title = 'Android中的GraphicBuffer同步机制-Fence';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://finalx.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>
